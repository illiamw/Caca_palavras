{"ast":null,"code":"import React from 'react';\nimport Data from '../conteudo/palavras08102019';\nimport { switchCase } from '@babel/types';\nexport default class Construtor extends React.Component {\n  constructor(props) {\n    super(props);\n    this.colunas = props.colunas;\n    this.linhas = props.linhas;\n    this.tentativas = this.vetorPosibilidades();\n    this.gabarito = Array(this.colunas * this.linhas).fill(0);\n    console.log(this.tentativas.sort());\n    console.log(this.gabarito);\n  }\n  /*\r\n  criandoLevel(col, lin) {\r\n      this.state.colunas = col;\r\n      this.state.linhas = lin;\r\n  }*/\n\n\n  testOcupa(rot, possibilidade, palavra) {\n    var finalposicao;\n    var inicialposicao = possibilidade;\n\n    switch (rot) {\n      case 0:\n        //horizontal\n        finalposicao = palavra.length + possibilidade;\n        if (finalposicao > this.colunas * this.linhas) return true;\n\n        for (let index = inicialposicao; index < finalposicao; index++) if (this.gabarito[index] != 0 && this.gabarito[index] != palavra[index - possibilidade]) return true;\n\n        for (let index = inicialposicao, inpalavras = 0; index < finalposicao; index++, inpalavras++) {\n          this.gabarito[index] = palavra[inpalavras];\n        } //this.tentativas.pop();\n\n\n        console.log(\"horizontal \" + this.tentativas.length);\n        return false;\n        break;\n\n      case 1:\n        //vertical\n        finalposicao = palavra.length * (this.colunas - 1) + possibilidade;\n        if (finalposicao > this.colunas * this.linhas) return true;\n\n        for (let index = inicialposicao, inpalavras = 0; index < finalposicao; index += this.colunas, inpalavras++) {\n          if (this.gabarito[index] != 0 && this.gabarito[index] != palavra[inpalavras]) return true;\n        }\n\n        for (let index = inicialposicao, inpalavras = 0; index < finalposicao; index += this.colunas, inpalavras++) {\n          this.gabarito[index] = palavra[inpalavras];\n        } //this.tentativas.pop();\n\n\n        console.log(\"vertical \" + this.tentativas.length);\n        return false;\n        break;\n\n      case 2:\n        //diagonal\n        //vertical\n        finalposicao = palavra.length + possibilidade;\n        finalposicao = palavra.length * this.colunas + finalposicao;\n        if (finalposicao > this.colunas * this.linhas) return true;\n\n        for (let index = inicialposicao, inpalavras = 0; index < finalposicao; index += this.colunas + 1, inpalavras) {\n          if (this.gabarito[index] != 0 && this.gabarito[index] != palavra[inpalavras]) return true;\n        }\n\n        for (let index = inicialposicao, inpalavras = 0; index < finalposicao; index += this.colunas + 1, inpalavras++) {\n          this.gabarito[index] = palavra[inpalavras];\n        } //this.tentativas.pop();\n\n\n        console.log(\"diagonal \" + this.tentativas.length);\n        return false;\n        break;\n\n      default:\n        console.log(\"Erro de rotação\");\n    } //Manter o loop\n\n\n    return true;\n  }\n\n  setPosicao(palavra, rot, possibilidade) {\n    var xespaco;\n    var yespaco;\n\n    switch (rot) {\n      case 0:\n        //horizontal \n        xespaco = this.colunas - possibilidade % this.colunas;\n        console.log(xespaco);\n\n        if (palavra.length <= xespaco) {\n          return this.testOcupa(rot, possibilidade, palavra);\n        }\n\n        break;\n\n      case 1:\n        //vertical\n        yespaco = this.linhas - Math.round(possibilidade / this.colunas);\n        console.log(yespaco);\n\n        if (palavra.length <= yespaco) {\n          return this.testOcupa(rot, possibilidade, palavra);\n        }\n\n        break;\n\n      case 2:\n        //diagonal\n        xespaco = this.colunas - possibilidade % this.linhas;\n        yespaco = this.linhas - Math.round(possibilidade / this.colunas);\n\n        if (palavra.length <= xespaco && palavra.length <= yespaco) {\n          return this.testOcupa(rot, possibilidade, palavra);\n        }\n\n        break;\n\n      default:\n        console.log(\"Erro de rotação\");\n    } //Manter o loop\n\n\n    return true;\n  }\n\n  geradorGabarito() {\n    var palavra;\n    var possibilidade = 0;\n    var rot = 0;\n    var percorrer = 1;\n    var naoinserido = true;\n\n    for (let index = 0; index <= 3; index++) {\n      do {\n        if (naoinserido) palavra = this.selecionarPalavras(rot);\n\n        do {\n          possibilidade = this.tentativas[this.tentativas.length - percorrer];\n          console.log(\"Possibilidae \" + possibilidade + \" palavra \" + palavra);\n          percorrer++;\n          naoinserido = this.setPosicao(palavra, rot, possibilidade);\n        } while (naoinserido && percorrer < this.tentativas.length);\n\n        console.log(\"nao inserido: \" + naoinserido);\n        percorrer = 1;\n      } while (naoinserido);\n\n      console.log(\"index -------------------------------- \" + index + \" palavra \" + palavra + \" rot \" + rot + \" possibilidade \" + possibilidade + \" flag \" + naoinserido);\n      if (rot >= 2) rot = 0;else rot++;\n      naoinserido = true;\n    }\n\n    return this.gabarito;\n  }\n\n  vetorPosibilidades() {\n    var tam = this.colunas * this.linhas;\n    var posicoes = Array(tam);\n\n    for (let i = 0; i < tam; i++) posicoes[i] = i;\n\n    let aux = 0,\n        ind1,\n        ind2;\n\n    for (let i = 0; i < tam; i++) {\n      ind1 = Math.floor(Math.random() * tam);\n      ind2 = Math.floor(Math.random() * tam);\n      aux = posicoes[ind1];\n      posicoes[ind1] = posicoes[ind2];\n      posicoes[ind2] = aux;\n    }\n\n    return posicoes;\n  }\n\n  selecionarPalavras(rot) {\n    var palavra;\n    var MAX;\n\n    switch (rot) {\n      case 0:\n        MAX = this.props.colunas;\n        break;\n\n      case 1:\n        MAX = this.props.linhas;\n        break;\n\n      case 2:\n        MAX = this.props.colunas > this.props.linhas ? this.props.colunas : this.props.linhas;\n        break;\n\n      default:\n        console.log(\"Erro rotação\");\n    }\n\n    var len = MAX + 1;\n    var index = 0;\n\n    while (len > MAX) {\n      palavra = Data[Math.floor(Math.random() * Data.length)][\"Resposta\"];\n      len = palavra[index].length;\n      index++;\n    }\n\n    return palavra;\n  }\n  /**\r\n   * @description geração Aleatória de letras \r\n   * @returns {Char} \"c\"\r\n   */\n\n\n  geradorChar(value) {\n    var alfabeto = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    var conteudo = Array(value);\n\n    for (let index = 0; index < value; index++) {\n      //conteudo[index] = alfabeto[Math.floor(Math.random() * alfabeto.length)];\n      conteudo[index] = \"a\";\n    }\n\n    for (let index = 0; index < conteudo.length; index++) {\n      if (this.gabarito[index] != 0) conteudo[index] = this.gabarito[index];\n    }\n\n    return conteudo;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/EIC/Documents/Caca_palavras/src/Componentes/Construtor.js"],"names":["React","Data","switchCase","Construtor","Component","constructor","props","colunas","linhas","tentativas","vetorPosibilidades","gabarito","Array","fill","console","log","sort","testOcupa","rot","possibilidade","palavra","finalposicao","inicialposicao","length","index","inpalavras","setPosicao","xespaco","yespaco","Math","round","geradorGabarito","percorrer","naoinserido","selecionarPalavras","tam","posicoes","i","aux","ind1","ind2","floor","random","MAX","len","geradorChar","value","alfabeto","conteudo"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport Data from '../conteudo/palavras08102019';\r\nimport { switchCase } from '@babel/types';\r\nexport default class Construtor extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.colunas = props.colunas;\r\n        this.linhas = props.linhas;\r\n        this.tentativas = this.vetorPosibilidades();\r\n        this.gabarito = Array(this.colunas * this.linhas).fill(0)\r\n        console.log(this.tentativas.sort());\r\n        console.log(this.gabarito);\r\n    }\r\n    /*\r\n    criandoLevel(col, lin) {\r\n        this.state.colunas = col;\r\n        this.state.linhas = lin;\r\n    }*/\r\n\r\n    testOcupa(rot, possibilidade, palavra) {\r\n        var finalposicao;\r\n        var inicialposicao = possibilidade;\r\n        switch (rot) {\r\n            case 0:\r\n                //horizontal\r\n                finalposicao = palavra.length + possibilidade;\r\n\r\n                if (finalposicao > this.colunas * this.linhas) return true;\r\n\r\n\r\n                for (let index = inicialposicao; index < finalposicao; index++) if (this.gabarito[index] != 0 && this.gabarito[index] != palavra[index - possibilidade]) return true;\r\n\r\n\r\n                for (let index = inicialposicao, inpalavras = 0; index < finalposicao; index++ , inpalavras++) {\r\n                    this.gabarito[index] = palavra[inpalavras];\r\n                }\r\n                //this.tentativas.pop();\r\n                console.log(\"horizontal \" + this.tentativas.length);\r\n                return false;\r\n\r\n\r\n                break;\r\n            case 1:\r\n                //vertical\r\n                finalposicao = (palavra.length * (this.colunas-1)) + possibilidade;\r\n\r\n                if (finalposicao > this.colunas * this.linhas) return true;\r\n                for (let index = inicialposicao, inpalavras=0; index < finalposicao; index += this.colunas, inpalavras++) {\r\n                    if (this.gabarito[index] != 0 && this.gabarito[index] != palavra[inpalavras]) return true;\r\n                }\r\n                \r\n                for (let index = inicialposicao, inpalavras = 0; index < finalposicao; index += this.colunas, inpalavras++) {\r\n                    this.gabarito[index] = palavra[inpalavras];\r\n                }\r\n                //this.tentativas.pop();\r\n                console.log(\"vertical \" + this.tentativas.length);\r\n                return false;\r\n\r\n                break;\r\n            case 2:\r\n                //diagonal\r\n                //vertical\r\n                finalposicao = palavra.length + possibilidade;\r\n                finalposicao = (palavra.length * this.colunas) + finalposicao;\r\n\r\n                if (finalposicao > this.colunas * this.linhas) return true;\r\n                for (let index = inicialposicao, inpalavras = 0; index < finalposicao; index += this.colunas + 1, inpalavras) {\r\n                    if (this.gabarito[index] != 0 && this.gabarito[index] != palavra[inpalavras]) return true;\r\n                }\r\n\r\n                for (let index = inicialposicao, inpalavras = 0; index < finalposicao; index += this.colunas + 1, inpalavras++) {\r\n                    this.gabarito[index] = palavra[inpalavras];\r\n                }\r\n                //this.tentativas.pop();\r\n                console.log(\"diagonal \" + this.tentativas.length);\r\n                return false;\r\n                break;\r\n            default:\r\n                console.log(\"Erro de rotação\");\r\n\r\n        }\r\n\r\n        //Manter o loop\r\n        return true;\r\n    }\r\n\r\n    setPosicao(palavra, rot, possibilidade) {\r\n        var xespaco;\r\n        var yespaco;\r\n        switch (rot) {\r\n            case 0:\r\n                //horizontal \r\n                xespaco = this.colunas - possibilidade % this.colunas;\r\n                console.log(xespaco);\r\n                if (palavra.length <= xespaco) {\r\n\r\n                    return this.testOcupa(rot, possibilidade, palavra);\r\n\r\n                }\r\n                break;\r\n            case 1:\r\n                //vertical\r\n                yespaco = this.linhas - Math.round(possibilidade / this.colunas);\r\n                console.log(yespaco);\r\n\r\n                if (palavra.length <= yespaco) {\r\n\r\n                    return this.testOcupa(rot, possibilidade, palavra);\r\n\r\n                }\r\n                break;\r\n            case 2:\r\n                //diagonal\r\n                xespaco = this.colunas - possibilidade % this.linhas;\r\n                yespaco = this.linhas - Math.round(possibilidade / this.colunas);\r\n\r\n                if (palavra.length <= xespaco && palavra.length <= yespaco) {\r\n\r\n                    return this.testOcupa(rot, possibilidade, palavra);\r\n\r\n                }\r\n\r\n                break;\r\n            default:\r\n                console.log(\"Erro de rotação\");\r\n\r\n\r\n        }\r\n        //Manter o loop\r\n\r\n        return true;\r\n\r\n    }\r\n    geradorGabarito() {\r\n        var palavra;\r\n        var possibilidade = 0;\r\n        var rot = 0;\r\n        var percorrer = 1;\r\n        var naoinserido = true;\r\n\r\n        for (let index = 0; index <= 3; index++) {\r\n            do {\r\n                if (naoinserido) palavra = this.selecionarPalavras(rot);\r\n                do {\r\n                    possibilidade = this.tentativas[this.tentativas.length - percorrer];\r\n                    console.log(\"Possibilidae \" + possibilidade + \" palavra \" + palavra);\r\n                    percorrer++;\r\n                    naoinserido = this.setPosicao(palavra, rot, possibilidade);\r\n                } while (naoinserido && percorrer < this.tentativas.length);\r\n                console.log(\"nao inserido: \" + naoinserido)\r\n                percorrer = 1;\r\n            } while (naoinserido);\r\n            console.log(\"index -------------------------------- \" + index + \" palavra \" + palavra + \" rot \" + rot + \" possibilidade \" + possibilidade + \" flag \" + naoinserido);\r\n            if (rot >= 2) rot = 0;\r\n            else rot++;\r\n            naoinserido = true;\r\n            \r\n\r\n        }\r\n        return this.gabarito;\r\n    }\r\n\r\n    vetorPosibilidades() {\r\n        var tam = this.colunas * this.linhas;\r\n        var posicoes = Array(tam);\r\n        for (let i = 0; i < tam; i++) posicoes[i] = i;\r\n        let aux = 0, ind1, ind2;\r\n        for (let i = 0; i < tam; i++) {\r\n            ind1 = Math.floor(Math.random() * tam);\r\n            ind2 = Math.floor(Math.random() * tam);\r\n            aux = posicoes[ind1];\r\n            posicoes[ind1] = posicoes[ind2];\r\n            posicoes[ind2] = aux;\r\n        }\r\n        return posicoes;\r\n    }\r\n\r\n\r\n    selecionarPalavras(rot) {\r\n        var palavra;\r\n        var MAX;\r\n        switch (rot) {\r\n            case 0:\r\n                MAX = this.props.colunas;\r\n                break;\r\n            case 1:\r\n                MAX = this.props.linhas;\r\n                break;\r\n            case 2:\r\n                MAX = this.props.colunas > this.props.linhas ? this.props.colunas : this.props.linhas;\r\n                break;\r\n            default:\r\n                console.log(\"Erro rotação\")\r\n\r\n        }\r\n\r\n        var len = MAX + 1;\r\n        var index = 0;\r\n        while (len > MAX) {\r\n            palavra = Data[Math.floor(Math.random() * Data.length)][\"Resposta\"];\r\n            len = palavra[index].length;\r\n            index++;\r\n        }\r\n\r\n        return palavra;\r\n    }\r\n\r\n    /**\r\n     * @description geração Aleatória de letras \r\n     * @returns {Char} \"c\"\r\n     */\r\n    geradorChar(value) {\r\n        var alfabeto = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\r\n        var conteudo = Array(value);\r\n        for (let index = 0; index < value; index++) {\r\n            //conteudo[index] = alfabeto[Math.floor(Math.random() * alfabeto.length)];\r\n            conteudo[index] = \"a\";\r\n        }\r\n\r\n        for (let index = 0; index < conteudo.length; index++) {\r\n            if (this.gabarito[index] != 0) conteudo[index] = this.gabarito[index];\r\n        }\r\n        return conteudo;\r\n    }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}